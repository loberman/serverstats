// procstats_grab - Process Stats Analyzer
// Copyright (C) 2024 Laurence Oberman
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/*!
    # analyze.rs

    procstats_grab Analysis and Playback Engine

    - Analyzes CSV process stat files generated by `gather` mode.
    - Computes per-process deltas and "spike" stats across samples.
    - Outputs top-N tables and generates SVG/PNG bar charts.
    - Provides playback (timestamped view) with delta columns.

    Use `run_analysis(filename)` for dashboard/tables/charts, and
    `run_playback(filename)` for delta view by timestamp.
*/

use std::collections::HashMap;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;
use serde::Deserialize;
use std::error::Error;

// plotters
use plotters::prelude::*;
use plotters::style::full_palette::BLUE;
use plotters::coord::Shift;

// -------------------------------------------------------
// PLAYBACK MODE (delta by timestamp)
// -------------------------------------------------------

pub fn run_playback(filename: &str, wide: bool) -> Result<(), Box<dyn std::error::Error>> {

    use chrono::{DateTime, Local, Utc};
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(true)
        .from_path(filename)?;
    let mut prev_map: std::collections::HashMap<(u32, String), (u64, u64, u64, u64)> = std::collections::HashMap::new();

    // Wider columns, COMM up to 24 chars for modern processes
    if wide {
        println!(
            "{:<8} {:>7}  {:<24} {:>8} {:>8} {:>12} {:>12}  {}",
            "Time", "PID", "COMM", "utime", "stime", "read_bytes", "write_bytes", "CMDLINE"
        );
    } else {
        println!(
            "{:<8} {:>7}  {:<24} {:>8} {:>8} {:>12} {:>12}",
            "Time", "PID", "COMM", "utime", "stime", "read_bytes", "write_bytes"
        );
    }

    for result in rdr.deserialize() {
        let row: ProcSample = result?;
        if row.pid != row.tid || row.comm.trim().is_empty() { continue; }
        let key = (row.pid, row.comm.clone());

        let (du, ds, dr, dw) = if let Some((pu, ps, pr, pw)) = prev_map.get(&key) {
            (
                row.utime.saturating_sub(*pu),
                row.stime.saturating_sub(*ps),
                row.read_bytes.saturating_sub(*pr),
                row.write_bytes.saturating_sub(*pw),
            )
        } else {
            (0, 0, 0, 0)
        };

        // Convert epoch to HH:MM:SS
        let tstr = DateTime::<Utc>::from_timestamp(row.ts_epoch as i64, 0)
            .map(|dt| dt.with_timezone(&Local).format("%H:%M:%S").to_string())
            .unwrap_or_else(|| row.ts_epoch.to_string());

        // COMM column: truncate but always 24 chars (adds 'â€¦' if needed)
        let comm = if row.comm.chars().count() > 23 {
            let mut s: String = row.comm.chars().take(23).collect();
            s.push('â€¦');
            s
        } else {
            format!("{:<24}", row.comm)
        };

        if wide {
            println!(
             "{:<8} {:>7}  {:<24} {:>8} {:>8} {:>12} {:>12}  {}",
             tstr, row.pid, comm, du, ds, dr, dw, row.cmdline
        );
       } else {
            println!(
            "{:<8} {:>7}  {:<24} {:>8} {:>8} {:>12} {:>12}",
            tstr, row.pid, comm, du, ds, dr, dw
             );
         }

        prev_map.insert(key, (row.utime, row.stime, row.read_bytes, row.write_bytes));
    }
    Ok(())
}

// =======================================================
// CSV STRUCT
// =======================================================

#[allow(dead_code)]
#[derive(Debug, Deserialize, Clone)]
struct ProcSample {
    ts_epoch: u64,
    pid: u32,
    ppid: u32,             // unused but required by CSV
    tid: u32,
    comm: String,
    state: String,         // unused but required
    utime: u64,
    stime: u64,
    num_threads: Option<u32>,
    vmrss_kb: Option<u64>,
    vm_size_kb: Option<u64>,
    read_bytes: u64,
    write_bytes: u64,
    cmdline: String,
}

#[derive(Default)]
struct ProcSummary {
    pid: u32,
    comm: String,
    cpu_total: u64,
    utime: u64,
    stime: u64,
    read_bytes_total: u64,
    write_bytes_total: u64,
    // New: spike (maximum delta per interval) for each metric
    cpu_total_spike: u64,
    utime_spike: u64,
    stime_spike: u64,
    read_bytes_spike: u64,
    write_bytes_spike: u64,
}

struct TableDef<'a> {
    fname: &'a str,
    chart: &'a str,
    title: &'a str,
    header: &'a str,
    metric: fn(&ProcSummary) -> u64,
    fmt: fn(u64, f64) -> String,
    spike_metric: fn(&ProcSummary) -> u64, // For chart: max single-sample delta
}

// =======================================================
// MAIN ANALYSIS
// =======================================================

pub fn run_analysis(filename: &str) -> Result<(), Box<dyn Error>> {
    // Collect all samples for line plotting
        let samples: Vec<ProcSample> = {
        let mut rdr = csv::Reader::from_path(filename)?;
        rdr.deserialize().filter_map(Result::ok).collect()
        };

    let output_dir = output_dir_for_datafile(filename);
    fs::create_dir_all(&output_dir)?;

    let mut rdr = csv::Reader::from_path(filename)?;
    let mut prev_map: HashMap<(u32, String, String), (u64, u64, u64, u64)> = HashMap::new();
    let mut proc_map: HashMap<(u32, String, String), ProcSummary> = HashMap::new();
    let mut all_samples: Vec<ProcSample> = Vec::new();

    for result in rdr.deserialize() {
        let row: ProcSample = result?;
        all_samples.push(row.clone());
        if row.pid != row.tid || row.cmdline.trim().is_empty() {
            continue;
        }
        let key = (row.pid, row.comm.clone(), row.cmdline.clone());

        let entry = proc_map.entry(key.clone()).or_insert(ProcSummary {
            pid: row.pid,
            comm: row.comm.clone(),
            ..Default::default()
        });

        if let Some((pu, ps, pr, pw)) = prev_map.get(&key) {
            let du = row.utime.saturating_sub(*pu);
            let ds = row.stime.saturating_sub(*ps);
            let dr = row.read_bytes.saturating_sub(*pr);
            let dw = row.write_bytes.saturating_sub(*pw);

            // Cumulative for table
            entry.cpu_total += du + ds;
            entry.utime += du;
            entry.stime += ds;
            entry.read_bytes_total += dr;
            entry.write_bytes_total += dw;

            // Update per-metric max deltas (spikes)
            entry.cpu_total_spike = entry.cpu_total_spike.max(du + ds);
            entry.utime_spike = entry.utime_spike.max(du);
            entry.stime_spike = entry.stime_spike.max(ds);
            entry.read_bytes_spike = entry.read_bytes_spike.max(dr);
            entry.write_bytes_spike = entry.write_bytes_spike.max(dw);
        }
        prev_map.insert(key, (row.utime, row.stime, row.read_bytes, row.write_bytes));
    }

    let hz = procfs_ticks_per_second().unwrap_or(100);

    let table_defs = [
        TableDef {
            fname: "top20_cpu_total.txt",
            chart: "top20_cpu_total",
            title: "Top 20 Processes by TOTAL CPU",
            header: "PID       CPU-TOTAL CPU-SECONDS COMM",
            metric: |e| e.cpu_total,
            fmt: |v, hz| format!("{:>10} {:>10.2}", v, v as f64 / hz),
            spike_metric: |e| e.cpu_total_spike,
        },
        TableDef {
            fname: "top20_cpu_user.txt",
            chart: "top20_cpu_user",
            title: "Top 20 Processes by USER CPU",
            header: "PID       USER-TICKS USER-SECONDS COMM",
            metric: |e| e.utime,
            fmt: |v, hz| format!("{:>10} {:>10.2}", v, v as f64 / hz),
            spike_metric: |e| e.utime_spike,
        },
        TableDef {
            fname: "top20_cpu_sys.txt",
            chart: "top20_cpu_sys",
            title: "Top 20 Processes by SYSTEM CPU",
            header: "PID       SYS-TICKS SYS-SECONDS COMM",
            metric: |e| e.stime,
            fmt: |v, hz| format!("{:>10} {:>10.2}", v, v as f64 / hz),
            spike_metric: |e| e.stime_spike,
        },
        TableDef {
            fname: "top20_read_bytes.txt",
            chart: "top20_read_bytes",
            title: "Top 20 Processes by READ bytes",
            header: "PID       READ-BYTES COMM",
            metric: |e| e.read_bytes_total,
            fmt: |v, _| format!("{:>12}", v),
            spike_metric: |e| e.read_bytes_spike,
        },
        TableDef {
            fname: "top20_write_bytes.txt",
            chart: "top20_write_bytes",
            title: "Top 20 Processes by WRITE bytes",
            header: "PID       WRITE-BYTES COMM",
            metric: |e| e.write_bytes_total,
            fmt: |v, _| format!("{:>12}", v),
            spike_metric: |e| e.write_bytes_spike,
        },
    ];

    let cpu_vec: Vec<_> = proc_map.values().collect();
    
    // Change: store tuples with all chart file paths
    let mut chart_list: Vec<(String, String, String, String, String, String)> = Vec::new();

    for t in &table_defs {
    // Table: Top 20 (by cumulative)
    let mut top20 = cpu_vec.clone();
    top20.sort_by(|a, b| (t.metric)(b).cmp(&(t.metric)(a)));
    top20.truncate(20);

    let rows: Vec<String> = top20.iter().map(|e| {
        let v = (t.metric)(e);
        let comm = e.comm.chars().take(18).collect::<String>();
        format!("{:>8} {} {:<20}", e.pid, (t.fmt)(v, hz as f64), comm)
    }).collect();

    write_table(&output_dir, t.fname, t.title, t.header, &rows)?;

    // Chart: Top 5 by per-sample spike (not cumulative)
    let mut top5 = cpu_vec.iter().copied().collect::<Vec<_>>();
    top5.sort_by(|a, b| (t.spike_metric)(b).cmp(&(t.spike_metric)(a)));
    top5.truncate(5);

    // --- Chart filenames
    let bar_svg = format!("{}/{}.svg", output_dir, t.chart);
    let bar_png = format!("{}/{}.png", output_dir, t.chart);

    let line_svg = format!("{}/line_{}.svg", output_dir, t.chart);
    let line_png = format!("{}/line_{}.png", output_dir, t.chart);

    // --- Plot charts
    plot_bar_chart_svg(&bar_svg, &top5, t.spike_metric, t.title, t.header)?;
    plot_bar_chart_png(&bar_png, &top5, t.spike_metric, t.title, t.header)?;

    // Pick the right metric for line charts (ProcSample-based)
    let sample_metric: fn(&ProcSample) -> u64 = match t.chart {
    "top20_cpu_total" => |s| s.utime + s.stime,
    "top20_cpu_user"  => |s| s.utime,
    "top20_cpu_sys"   => |s| s.stime,
    "top20_read_bytes"  => |s| s.read_bytes,
    "top20_write_bytes" => |s| s.write_bytes,
    _ => |_| 0,
    };

    plot_line_chart_svg(&line_svg, &samples, &top5, sample_metric, t.title)?;
    plot_line_chart_png(&line_png, &samples, &top5, sample_metric, t.title)?;

    // --- Push all paths to chart_list
    chart_list.push((t.fname.to_string(), t.title.to_string(),
                    bar_svg, bar_png, line_svg, line_png));
    }

// ...later...
write_html_dashboard(&output_dir, &table_defs, &chart_list)?;


    write_html_dashboard(&output_dir, &table_defs, &chart_list)?;

    println!("All tables and charts written to {}/", output_dir);
    Ok(())
}

// =======================================================
// TABLE WRITER
// =======================================================

fn write_table(outdir: &str, fname: &str, title: &str, header: &str, rows: &[String]) -> std::io::Result<()> {
    let path = Path::new(outdir).join(fname);
    let mut f = File::create(path)?;
    writeln!(f, "{}", title)?;
    writeln!(f, "{}", header)?;
    for r in rows {
        writeln!(f, "{}", r)?;
    }
    Ok(())
}

// =======================================================
// CHART PLOTTING
// =======================================================

fn plot_bar_chart_svg(
    filename: &str,
    entries: &[&ProcSummary],
    metric: fn(&ProcSummary) -> u64,
    title: &str,
    _header: &str,
) -> Result<(), Box<dyn Error>> {
    let root = SVGBackend::new(filename, (900, 320)).into_drawing_area();
    draw_bars(root, entries, metric, title)
}

fn plot_bar_chart_png(
    filename: &str,
    entries: &[&ProcSummary],
    metric: fn(&ProcSummary) -> u64,
    title: &str,
    _header: &str,
) -> Result<(), Box<dyn Error>> {
    let root = BitMapBackend::new(filename, (900, 320)).into_drawing_area();
    draw_bars(root, entries, metric, title)
}

// The key fix: add the where-clause to satisfy plotters generic error lifetime
fn draw_bars<DB: DrawingBackend>(
    root: DrawingArea<DB, Shift>,
    entries: &[&ProcSummary],
    metric: fn(&ProcSummary) -> u64,
    title: &str,
) -> Result<(), Box<dyn Error>>
where
    <DB as DrawingBackend>::ErrorType: 'static,
{
    root.fill(&WHITE)?;
    // Legend: PID:COMM (truncate comm for readability)
    let xs: Vec<String> = entries
        .iter()
        .map(|e| format!("{}:{}", e.pid, truncate_str(&e.comm, 12)))
        .collect();

    let ys: Vec<u64> = entries.iter().map(|e| metric(e)).collect();

    let ymax = ys.iter().max().copied().unwrap_or(1);

    let mut chart = ChartBuilder::on(&root)
        .caption(title, ("sans-serif", 18))
        .margin(10)
        .x_label_area_size(40)
        .y_label_area_size(60)
        .build_cartesian_2d(
            0f32..entries.len() as f32,
            0f32..((ymax as f32) * 1.10),
        )?;

    chart
        .configure_mesh()
        .x_labels(xs.len().min(20).max(5))
        .x_label_formatter(&|i| xs.get(*i as usize).cloned().unwrap_or_default())
        .x_desc("PID:COMM")
        .y_desc("Value")
        .draw()?;

    // Wider bars
    let bar_width = 0.7f32;

    chart.draw_series(
        ys.iter().enumerate().map(|(i, y)| {
            let center = i as f32;
            let x0 = center - bar_width / 2.0;
            let x1 = center + bar_width / 2.0;

            Rectangle::new(
                [(x0, 0.0), (x1, *y as f32)],
                BLUE.filled(),
            )
        }),
    )?;

    root.present()?;

    Ok(())
}

// Helper to truncate string (for comm display)
fn truncate_str(s: &str, max_len: usize) -> String {
    if s.chars().count() > max_len {
        let mut truncated = s.chars().take(max_len - 1).collect::<String>();
        truncated.push('â€¦');
        truncated
    } else {
        s.to_string()
    }
}

use plotters::style::{full_palette, IntoFont};
use plotters::element::PathElement;

fn plot_line_chart_svg(
    filename: &str,
    samples: &[ProcSample],
    top5: &[&ProcSummary],
    metric: fn(&ProcSample) -> u64,
    title: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let root = SVGBackend::new(filename, (900, 320)).into_drawing_area();
    draw_lines(root, samples, top5, metric, title)
}

fn plot_line_chart_png(
    filename: &str,
    samples: &[ProcSample],
    top5: &[&ProcSummary],
    metric: fn(&ProcSample) -> u64,
    title: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let root = BitMapBackend::new(filename, (900, 320)).into_drawing_area();
    draw_lines(root, samples, top5, metric, title)
}

fn draw_lines<DB: DrawingBackend>(
    root: DrawingArea<DB, Shift>,
    samples: &[ProcSample],
    top5: &[&ProcSummary],
    metric: fn(&ProcSample) -> u64,
    title: &str,
) -> Result<(), Box<dyn std::error::Error>>
where
    <DB as DrawingBackend>::ErrorType: 'static,
{
    root.fill(&WHITE)?;
    let comms: Vec<_> = top5.iter().map(|e| e.comm.clone()).collect();
    let colors = [
        &full_palette::BLUE,
        &full_palette::RED,
        &full_palette::GREEN,
        &full_palette::PURPLE,
        &full_palette::CYAN,
    ];

    let min_ts = samples.iter().map(|s| s.ts_epoch as i64).min().unwrap_or(0);
    let max_ts = samples.iter().map(|s| s.ts_epoch as i64).max().unwrap_or(1);

    // Determine if this is a CPU metric (needs HZ conversion)
    let title_lc = title.to_lowercase();
    let is_cpu = title_lc.contains("cpu");

    let hz = procfs_ticks_per_second().unwrap_or(100) as f64;

    let mut series: Vec<(String, Vec<(i64, f64)>)> = Vec::new();

    for comm in &comms {
        let mut per_pid: HashMap<u32, Vec<(i64, u64)>> = HashMap::new();
        for s in samples.iter().filter(|s| &s.comm == comm) {
            per_pid.entry(s.pid)
                .or_insert_with(Vec::new)
                .push((s.ts_epoch as i64, metric(s)));
        }
        let mut all_deltas: Vec<(i64, f64)> = Vec::new();
        for (_pid, mut pts) in per_pid {
            pts.sort_by_key(|x| x.0);
            let mut prev: Option<(i64, u64)> = None;
            for (ts, value) in pts {
                if let Some((_prev_ts, prev_val)) = prev {
                    let mut delta = value.saturating_sub(prev_val) as f64;
                    // ðŸ”¥ Convert CPU ticks to seconds
                    if is_cpu {
                        delta = delta / hz;
                    }
                    all_deltas.push((ts, delta));
                }
                prev = Some((ts, value));
            }
        }
        all_deltas.sort_by_key(|x| x.0);
        series.push((comm.clone(), all_deltas));
    }

    let max_val = series.iter()
        .flat_map(|(_, v)| v.iter().map(|(_, y)| *y))
        .max_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))
        .unwrap_or(1.0);

    let mut chart = ChartBuilder::on(&root)
        .caption(title, ("sans-serif", 18))
        .margin(10)
        .x_label_area_size(60)
        .y_label_area_size(60)
        .build_cartesian_2d(
            min_ts..max_ts,
            0f64..(max_val * 1.10),
        )?;

    chart
        .configure_mesh()
        .x_labels(10)
        .x_label_style(("sans-serif", 12).into_font())
        .x_label_formatter(&|ts| {
            let dt_utc = chrono::DateTime::<chrono::Utc>::from_timestamp(*ts as i64, 0)
                .unwrap_or_else(|| chrono::DateTime::<chrono::Utc>::from_timestamp(0, 0).unwrap());
            let dt_local = dt_utc.with_timezone(&chrono::Local);
            dt_local.format("%H:%M:%S").to_string()
        })
        .y_desc(if is_cpu { "Delta (seconds)" } else { "Delta" })
        .x_desc("Time")
        .draw()?;

    for (ix, (comm, data)) in series.iter().enumerate() {
        if !data.is_empty() {
            chart.draw_series(LineSeries::new(
                data.iter().map(|(ts, y)| (*ts, *y)),
                colors[ix % colors.len()],
            ))?
            .label(comm.clone())
            .legend(move |(x, y)| {
                PathElement::new(vec![(x, y), (x + 20, y)], colors[ix % colors.len()])
            });
        }
    }

    chart
        .configure_series_labels()
        .position(SeriesLabelPosition::UpperRight)
        .background_style(&WHITE.mix(0.8))
        .border_style(&BLACK)
        .draw()?;

    root.present()?;
    Ok(())
}

// =======================================================
// HTML DASHBOARD
// =======================================================
fn write_html_dashboard(
    outdir: &str,
    _defs: &[TableDef],
    charts: &[(String, String, String, String, String, String)],
) -> std::io::Result<()> {
    let index = Path::new(outdir).join("index.html");
    let mut f = File::create(index)?;

    writeln!(f, r#"<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>procstats_grab Analysis</title>
<style>
body {{ font-family:sans-serif; margin:2em; }}
img.chart {{ max-width:95vw; margin:1em 0; border:1px solid #ccc; }}
</style>
</head>
<body>
<h1>procstats_grab Analysis Results</h1>
<ul>
"#)?;

    for (fname, title, bar_svg, bar_png, line_svg, line_png) in charts {
        writeln!(
            f,
            r#"<li><a href="{fname}">{title}</a></li>
<img class="chart" src="{bar_img}" onerror="this.src='{bar_png}'">
<img class="chart" src="{line_img}" onerror="this.src='{line_png}'">"#,
            fname = fname,
            title = title,
            bar_img = Path::new(bar_svg).file_name().unwrap().to_string_lossy(),
            bar_png = Path::new(bar_png).file_name().unwrap().to_string_lossy(),
            line_img = Path::new(line_svg).file_name().unwrap().to_string_lossy(),
            line_png = Path::new(line_png).file_name().unwrap().to_string_lossy()
        )?;
    }

    writeln!(f, "</ul></body></html>")?;
    Ok(())
}


// =======================================================
// UTILS
// =======================================================

fn output_dir_for_datafile(datafile: &str) -> String {
    Path::new(datafile)
        .file_stem()
        .unwrap_or_default()
        .to_string_lossy()
        .to_string()
}

fn procfs_ticks_per_second() -> Option<u64> {
    unsafe {
        let t = libc::sysconf(libc::_SC_CLK_TCK);
        if t > 0 { Some(t as u64) } else { None }
    }
}

